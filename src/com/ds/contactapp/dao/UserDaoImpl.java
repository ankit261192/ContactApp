package com.ds.contactapp.dao;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import com.ds.contactapp.domain.User;
import com.ds.contactapp.rm.UserRowMapper;
@Repository//as this class will interact with db directly,hence marking them as repository
public class UserDaoImpl extends BaseDao implements UserDao {

	@Override
	public void save(User u) {
		//named parameters are named with : and we can change the names also
		String sql="insert into user(name,phone,email,address,loginname,password,role,loginstatus)values(:name,:phone,:email,:address,:loginname,:password,:role,:loginstatus)";
				
//binding values for the parameters
		Map m= new HashMap();//creating hashmap object
		m.put("name", u.getName());//binding parameters
		m.put("phone", u.getPhone());
		m.put("email", u.getEmail());
		m.put("address", u.getAddress());
		m.put("loginname", u.getLoginname());
		m.put("password", u.getPassword());
		m.put("role", u.getRole());
		m.put("loginstatus", u.getLoginstatus());
		
		KeyHolder kh=new GeneratedKeyHolder();//value for auto increment fields after insert will be stored in keyholder.
		SqlParameterSource ps= new MapSqlParameterSource(m); //defines source for the values of named parameters,in our case, from map m
		super.getNamedParameterJdbcTemplate().update(sql,ps,kh);//inherited from parent class
		Integer userid=kh.getKey().intValue();//to get userid as it is autogenerated and not passed.
		u.setUserid(userid);//to set the user id to user object to access it from where we call it
	}

	@Override
	public void update(User u) {
		// TODO Auto-generated method stub
		String sql="update user set name=:name,phone=:phone,email=:email,address=:address,role=:role,loginstatus=:loginstatus where userid=:userid";
		Map m=new HashMap();
		m.put("name", u.getName());//binding parameters
		m.put("phone", u.getPhone());
		m.put("email", u.getEmail());
		m.put("address", u.getAddress());
		m.put("role", u.getRole());
		m.put("loginstatus", u.getLoginstatus());
		m.put("userid", u.getUserid());

		SqlParameterSource ps=new MapSqlParameterSource(m);
		getNamedParameterJdbcTemplate().update(sql, m);
	}

	@Override
	public void delete(User u) { 
		//throw new UnsupportedOperationException ("not supported yet");
		this.delete(u.getUserid());//takes user id from user object and then deletes it
		}
	
		
	

	@Override
	public void delete(Integer userid) {
		// TODO Auto-generated method stub
		String sql="delete from user where userid=?";
		getJdbcTemplate().update(sql,userid);
	}

	@Override
	public User findById(Integer userid) {
		/**
		 * we need to use rowmapper because a single object will be returned when
		 *  we passpk and result will be mapped to an object
		 */
		String sql="select userid,name,email,address,phone,loginName,role,loginStatus from user where userid=?";
		// as we need single record from db
		User u=getJdbcTemplate().queryForObject(sql, new UserRowMapper(),userid);
		return u;
	}

	@Override
	public List<User> findAll() {
		String sql="select userid,name,email,address,phone,loginName,role,loginStatus from user";
		List<User> users=getJdbcTemplate().query(sql,new UserRowMapper());
		return users;
	}

	@Override
	public List<User> findByProperty(String propName,Object propValue) {
		String sql="select userid,name,email,address,phone,loginName,role,loginStatus from user where"+" "+propName+"=?";
		return getJdbcTemplate().query(sql,new UserRowMapper(),propValue);
	}

}
